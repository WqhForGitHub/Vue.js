# 9.1 解析器的作用

**`解析器要实现的功能是将模板解析成 AST。`** 

例如：

```vue
<div>
    <p>{{ name }}</p>
</div>
```



上面的代码是一个比较简单的模板，它转换成 **`AST`** 后的样子如下：

```javascript
{
    tag: "div",
    type: 1,
    staticRoot: false,
    static: false,
    plain: true,
    parent: undefined,
    attrsList: [],
    attrsMap: {},
    children: [
        {
            tag: "p",
            type: 1,
            staticRoot: false,
            static: false,
            plain: true,
            parent: {
                 tag: "div",
    			 type: 1,
                staticRoot: false,
                static: false,
                plain: true,
                parent: undefined,
                attrsList: [],
                attrsMap: {},
            },
           attrsList: [],
           attrsMap: {},
           children: [
               {
                   type: 2,
                   text: "{{name}}",
                   static: false,
                   expression: "_s(name)"
               }
           ]
        }
    ]
}
```





# 9.2 解析器内部运行原理

```javascript
parseHTML(template, {
    start(tag, attrs, unary) {
       // 每当解析到标签的开始位置时，触发该函数                            
    },
    end() {
       // 每当解析到标签的结束位置时，触发该函数 
    },
    chars(text) {
       // 每当解析到文本时，触发该函数
    },
    comment(text) {
       // 每当解析到注释时，触发该函数                                                                 
    }
})
```

因此，我们可以在钩子函数中构建 AST 节点。在 start 钩子函数中 **`构建元素类型的节点`** ，在 chars 钩子函数中 **`构建文本类型的节点`** ，在 comment 钩子函数中 **`构建注释类型的节点`** 。当 HTML 解析器不再触发钩子函数时，就说明所有模板都解析完毕，所有类型的节点都在钩子函数中构建完成，即 **`AST 构建完成`** 。我们发现，钩子函数 **`start`** 有三个参数，分别是 **`tag、attrs 和 unary`** ，它们分别说明 **`标签名、标签的属性以及是否是自闭合标签`** 。而文本节点的钩子函数 **`chars`**  和注释节点的钩子函数 **`comment`** 都只有一个参数，只有 text。这是因为构建元素节点时需要知道标签名、属性和自闭合标识，而构建注释节点和文本节点时只需要知道文本即可。什么是自闭合标签？举个简单的例子，input 标签就属于自闭合标签： **`<input type="text" />`** ，而 div 标签就不属于自闭合标签： **`<div></div>`**。在 start 钩子函数中，我们可以使用这三个参数来构建一个 **`元素类型的 AST 节点`** ，例如：

```javascript
function createASTElement (tag, attrs, parent) {
    return {
        type: 1,
        tag,
        attrsList: attrs,
        parent,
        children: []
    }
}

parseHTML(template, {
    start (tag, attrs, unary) {
        let element = createASTElement(tag, attrs, currentParent);
    }
})
```

**`在上面的代码中，我们在钩子函数 start 中构建了一个元素类型的 AST 节点。`** 

**`如果是触发了文本的钩子函数，就使用参数中的文本构建一个文本类型的 AST 节点 ，例如：`** 

```javascript
parseHTML(template, {
    chars (text) {
        let element = { type: 3, text }
    }
})
```

**`如果是注释，就构建一个注释类型的 AST 节点，例如：`** 

```javascript
parseHTML(template, {
    comment (text) {
        let element = { type: 3, text, isComment: true }
    }
})
```



**`构建节点是没有层级的，我们需要一套逻辑来实现层级关系，让每一个 AST 节点都能找到它的父级。下面我们来介绍一下如何构建 AST 层级关系。构建 AST 层级关系其实非常简单，我们只需要维护一个栈（stack）即可，用栈来记录层级关系，这个层级关系也可以理解为 DOM 的深度。下面我们用一个具体的例子来描述如何从 0 到 1 构建一个带层级关系的 AST。假设有这样一个标签：`**

```                                                              html
<div>
    <h1>我是 Berwin</h1>
    <p>我今年 23 岁</p>
</div>
```



![](https://github.com/WqhForGitHub/Vue.js/blob/vue2%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vue.js/static/9/9.1.png?raw=true)





# 9.3 HTML 解析器



## 1. 运行原理



循环 HTML 模板的伪代码如下：

```javascript
function parseHTML(html, options) {
    while (html) {
        // 截取模板字符串并触发钩子函数
    }
}
```

这些被截取的片段分很多种类型，示例如下。

* **`开始标签，例如 <div>`** 。
* **`结束标签，例如 </div>`** 。
* **`HTML 注释，例如  <!-- 我是注释 -->`** 。
* **`DOCTYPE，例如 <!DOCTYPE html>`** 
* **`条件注释：例如 <!-- [if !IE] --> 我是注释 <!-- <!endif] -->`** 
* **`文本，例如我是 Berwin`** 。

**`通常，最常见的是开始标签、结束标签、文本以及注释`** 。



## 2. 截取开始标签

**`如何使用正则表达式来匹配模板以开始标签开头？`** 

```javascript
const ncname = '[a-zA-Z_][\\w\\-\\.]*';
const qnameCapture = `((?:${ncname}\\:)?${ncname}`;
const startTagOpen = new RegExp(`^<${qnameCapture}`);

// 以开始标签开始的模板
'<div></div>'.match(startTagOpen); // ["<div", "div", index: 0, input: "<div></div>"]
```

